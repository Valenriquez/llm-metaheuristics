import ollama 
import os
import json
import re
from dataclasses import dataclass

from chromadb.api.models.Collection import Collection

@dataclass
class Exploitation:
    problem_id: int
    dimensions: int
    model: str = "qwen2.5-coder:latest"
    model_embed: str = "all-minilm:latest"
    optuna_collection:  Collection = None 
    converted_metaheuristic: str = None
    metaheuristic_file: str = None


    def extract_metaheuristic(self, metaheuristic_file):
        pattern = r'heur\s*=\s*\[(.*?)\]' 
        match = re.search(pattern, metaheuristic_file, re.DOTALL)

        if match:
            extracted_content = match.group(1).strip()  
            print("MATCH", extracted_content)

            output = ollama.generate(
            model = self.model,
            prompt = f"""Modify this metaheuristic: {extracted_content}, DO NOT ADD any new parameters. 
                         You must make the following changes based on the parameter type:

                        1. **If the parameter provides a numeric value:**
                        - Change it to the format:
                            name_variable = trial.suggest_float('name_variable', lower_limit, upper_limit)
                        - Use appropriate ranges for `lower_limit` and `upper_limit`. 
                            - **Rules for ranges:**
                            - For **radius**, the maximum is 0.9.
                            - For **angle**, the maximum is 25.
                            - For **swarm_conf** or **self_conf**, the maximum is 3.
                        - **Incorrect Example:**
                            'name_variable': trial.suggest_categorical('name_variable', ['2.54'])
                        - **Correct Example:**
                            'beta': trial.suggest_float('beta', 1.5, 4.5),
                        - Always include a comma after the modified parameter.

                        2. **If the parameter provides a category:**
                        - Modify it to the format:
                            'category_name': trial.suggest_categorical('category_name', ['option_1', 'option_2', 'option_3'])
                        - Include at least **three options**. ALWAYS USE MORE THAN ONE option.
                        - **Incorrect Example:**
                            'category_name': trial.suggest_categorical('category_name', ['option_1'])
                        - **Correct Example:**
                            'distribution': trial.suggest_categorical('distribution', ['uniform', 'gaussian','levy'])

                        3. **Rules for specific category types:**
                        - "version": "inertial", "constriction"
                        - "distribution": "uniform", "gaussian", "levy"
                        - "pairing": "rank", "cost", "random", "tournament_2_100"
                        - "crossover": "single", "two", "uniform", "blend", "linear_0.5_0.5"
                        - "expression": "rand", "best", "current", "current-to-best", "rand-to-best", "rand-to-best-and-current"

                        4. **General Guidelines:**
                        - Do not change anything else in the metaheuristic. Only modify the parameters as instructed.
                        - Do not add extra words, explanations, or paragraphs. Follow these instructions strictly.
                        """
            ) 
            # Deleted from the prompt: , take a look to the other parameters provided for the operators and selectors: {optuna_data}
            #print("is it doing it wrong", output['response'])
            self.converted_metaheuristic = output['response']
            return self.converted_metaheuristic
        else:
            return None

    def exploitation(self, number_iteration):
        optuna_template =  f"""
            import optuna
            import sys
            from pathlib import Path

            project_dir = Path(__file__).resolve().parents[2] # Remember to write well this line: 'project_dir = Path(__file__).resolve().parents[2]'
            sys.path.insert(0, str(project_dir))

            import metaheuristic as mh
            import numpy as np
            from joblib import Parallel, delayed
            import multiprocessing
            from P1 import P1

            # Parámetros iniciales
            problem_id =  {self.problem_id} 
            instance = 1
            dimension = {self.dimensions}
            num_agents = {self.num_of_agents}
            num_iterations = 100
            num_replicas = 10

            # Definir la función para evaluar el rendimiento de la secuencia
            def evaluate_sequence_performance(sequence, prob, num_agents, num_iterations, num_replicas):
                def run_metaheuristic():
                    met = mh.Metaheuristic(prob, sequence, num_agents=num_agents, num_iterations=num_iterations)
                    met.run()
                    _, f_best = met.get_solution()
                    return f_best

                # Número de núcleos disponibles para paralelización
                num_cores = min(multiprocessing.cpu_count(), num_replicas)
                results_parallel = Parallel(n_jobs=num_cores, prefer="threads")(delayed(run_metaheuristic)() for _ in range(num_replicas))

                # Calcular la métrica de rendimiento usando la mediana y el IQR
                fitness_values = results_parallel
                fitness_median = np.median(fitness_values)
                iqr = np.percentile(fitness_values, 75) - np.percentile(fitness_values, 25)
                performance_metric = fitness_median + iqr

                return performance_metric

            # Definir el objetivo de Optuna
            def objective(trial):
                heur = [
                    ### The metaheuristic goes here below:
                ]

                ioh_problem = P1.create_ioh_problem(problem_id, instance, dimension)
                fun = P1(variable_num=dimension, problem=ioh_problem)
                prob = fun.get_formatted_problem()
                performance = evaluate_sequence_performance(heur, prob, num_agents, num_iterations, num_replicas)
                
                return performance

            # Crear y ejecutar el estudio de Optuna
            study = optuna.create_study(direction="minimize")  
            study.optimize(objective, n_trials=num_replicas) 

            print("Mejores hiperparámetros encontrados:")
            print(study.best_params)

            print("Mejor rendimiento encontrado:")
            print(study.best_value)
        """

        print("Beginning with exploitation number --->",  number_iteration)

        # Query and Generate Optuna File - - - - - - - - - - - - - - - - - - -
        optuna_task = f"""
        You are an expert in natural computing. Your task is to generate code adhering strictly to the given template. 

        ### Rules:
        1. **Plain Text Only**: Do not include Markdown or triple backticks (```). Outputs must be plain text.
        2. **No Deviations**: Follow the provided template exactly—no additions, modifications, or extra explanations.
        3. **Use the follwoing template**: {optuna_template}
        ### Template Modifications:
        - Repace with:
        problem_id = {self.problem_id}    
        instance = 1
        dimension = {self.dimensions}     
        num_agents= {self.num_of_agents}    
        num_iterations = 100
        num_replicas = 10
        - Replace `def objective(trial):` with:
            def objective(trial):
                heur = [
                    {self.converted_metaheuristic}
                ]
        - Use this format for `heur`:
            heur = [
                ('[operator_name]', {{'parameter1': value1, 'parameter2': value2}}, '[selector_name]'),
                ('[operator_name]', {{'parameter1': value1, 'parameter2': value2}}, '[selector_name]')
            ]
        Any deviation from the above instructions is incorrect.
        """
        output = ollama.generate(
            model=self.model,
            prompt=f"""{optuna_task}
            Remember to put:     performance = evaluate_sequence_performance(heur, prob, num_agents={self.num_of_agents}, num_iterations=100, num_replicas=30)
            """
        )
        response = output.get('response', '').strip()
        print("response:::" ,response)

    def run(self):
        self.extract_metaheuristic(self, self.metaheuristic_file)
        self.exploitation(self, self.metaheuristic_file)
